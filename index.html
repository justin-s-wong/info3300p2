<html>

</html>

<head>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        .tooltip {
            pointer-events: none;
        }

        .mouseover{
            pointer-events: none;
        }

        .sliderContainer {
            margin: auto;
            width: 50%;
            padding: 15px;
        }

        .buttonContainer {
            margin: auto;
            width: 50%;
            padding-top: 10px
        }

        .yearBox {
            margin: auto;
            width: 50%;
            padding-bottom: 10px
        }

        .sliderValue {
            margin: auto;
            width: 50%;
            border: 2px solid black;
            padding: 10px;
        }        

        .instruction {
            margin: auto;
            width: 50%;
            padding: 10px;
        }        
    </style>

    <title>INFO 3300 - Project 2 - Fedinard Nyanyo (fen7), Justin Wong (jsw345), Merry Zebro (mz289), Stephan Volynets (svv6)</title>
</head>

<body>
    <h2>INFO 3300 - Project 2 - Fedinard Nyanyo (fen7), Justin Wong (jsw345), Merry Zebro (mz289), Stephan Volynets
        (svv6)</h2>
    <p id="p1">
        <div class="instruction" style="width: 450px; height: 130px; text-align: center">
            - Press space to pause/unpause slider animation
            </br>
            </br>
            - Can zoom in and pan on map
            </br>
            </br>
            - Click on individual countries to zoom in on them
            </br>
            </br>
            - Hover over individual countries to see more specific information
        </div>
        <div class="buttonContainer" style="width: 300px; height: 60px; text-align:center;">
            <button id="life" class="button">Show Life Expectancy</button>
            <button id="pop" class="button">Show Population</button>
            <button id="resetZoom" class="button">Reset Zoom</button>
        </div>
        <div class="yearBox" style="width: 275px; height: 50px; text-align: center">
            Input (valid) year and press 'Enter' key:
            <input type="text" id="yearText" name="yearText" style="width: 37.5px;">
        </div>
        <div class="sliderValue" style="width: 100px; height: 20px; text-align: center">Year: 1960</div>
        <div class="buttonContainer" style="width: 100px; height: 25px; text-align:center;">
            <button id="play" class="button">Play</button>
            <button id="stop" class="button">Stop</button>
        </div>
        <div class="sliderContainer" style="width: 800px; height: 60px">
            <input type="range" class="yearSlider" min="1960" max="2022" value="1960" style="width: 800px;" step="1"></input>
        </div>
        <svg id="mapArea" height="750" width="1500"></svg>

        <script>

            // Variable that tells us what data we want to show on the map: Life expectancy or Population
            // default to life expectancy when page is loaded
            var showLife = true; 
            var mapTransitionTime = 700; // Variable to hold how long we want the transition between colors to take

            // below code credited in codesource.js
            // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

            // modified Prof. Rz drawLegend() code to make it appear inside of my map's svg canvas
            function drawLegend(mapSelector, legendColorScale, height, width) {
                // This code should adapt to a variety of different kinds of color scales
                // Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS

                const offsets = {
                    width: 50,
                    top: 25,
                    bottom: 25
                };
                // Number of integer 'pixel steps' to draw when showing continuous scales
                // Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
                const stepSize = 4;
                // Extend the minmax by 0% in either direction to expose more features by default
                const minMaxExtendPercent = 0;


                const mapArea = d3.select(mapSelector);
                const legendHeight = height;
                const legendBarWidth = width - (offsets.width * 2);

                // add text to top left and top right of color scale legend
                let leftText = mapArea.append("g")
                leftText.append("rect")
                        .attr("fill", "white")
                        .attr("opacity", 1)
                        .attr("x", -15)
                        .attr("y", -10)
                        .attr("width",legendBarWidth + 30)
                        .attr("height",legendHeight + 20)
                        .attr("stroke", "black")
                leftText.attr("class", "text")
                        .attr("transform", `translate(${offsets.width}, ${15})`)
                        .append("text")
                        .attr("dominant-baseline", "middle")
                        .style("fill", "black")
                        .style("font-family", "Monaco")
                        .style("font-size", 13)
                        .text(showLife ? "Low Life Expectancy" : "Low Pop. Number")
                        .attr("x", -13)
                
                mapArea.append("g")
                       .attr("class", "text")
                       .attr("transform", `translate(${legendBarWidth + offsets.width}, ${15})`)
                       .append("text")
                       .attr("text-anchor", "end")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 13)
                       .text(showLife ? "High Life Expectancy" : "High Pop. Number")
                       .attr("x", 13)
                
                const legendMinMax = d3.extent(legendColorScale.domain());
                // recover the min and max values from most kinds of numeric scales
                const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
                const barHeight = legendHeight - offsets.top - offsets.bottom;

                // In this case the "data" are pixels, and we get numbers to use in colorScale
                // Use this to make axis labels
                let barScale = undefined;
                if (showLife) {
                    barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
                        legendMinMax[1] + minMaxExtension])
                    .range([0, legendBarWidth]);
                }
                else {
                    barScale = d3.scaleLog().domain([legendMinMax[0] - minMaxExtension,
                        legendMinMax[1] + minMaxExtension])
                    .range([0, legendBarWidth]);
                }
                let barAxis = showLife ? d3.axisBottom(barScale).ticks(10).tickFormat(d3.format("d"))
                                       : d3.axisBottom(barScale).ticks(10).tickFormat(d => {
                                            let str = String(Math.round(d));
                                            if (str.length < 7) return d3.format(",")(Math.round(d));
                                            if (str.length < 10) return str.substring(0, str.length - 6) + "M";
                                            else return str.substring(0, str.length - 9) + "B"
                                       });

                // Place for bar slices to live, in our case we place them at the top left of the selected canvas
                let bar = mapArea.append("g")
                                 .attr("class", "legend colorbar")
                                 .attr("transform", `translate(${offsets.width},${10 + barHeight})`)

                // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******

                // Check if we're using a binning scale - if so, we make blocks of color
                if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                    // Get the thresholds
                    let thresholds = [];
                    if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                    else { thresholds = legendColorScale.quantiles() }

                    const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

                    // Use the quantile breakpoints plus the min and max of the scale as tick values
                    barAxis.tickValues(barThresholds);

                    // Draw rectangles between the threshold segments
                    for (let i = 0; i < barThresholds.length - 1; i++) {
                        let dataStart = barThresholds[i];
                        let dataEnd = barThresholds[i + 1];
                        let pixelStart = barAxis.scale()(dataStart);
                        let pixelEnd = barAxis.scale()(dataEnd);

                        bar.append("rect")
                            .attr("x", pixelStart)
                            .attr("y", 0)
                            .attr("width", pixelEnd - pixelStart)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale((dataStart + dataEnd) / 2.0));
                    }
                }
                // Else if we have a continuous / roundable scale
                //  In an ideal world you might construct a custom gradient mapped to the scale
                //  For this one, we use a hack of making stepped rects
                else if (legendColorScale.hasOwnProperty('rangeRound')) {
                    // NOTE: The barAxis may round min and max values to make them pretty
                    // ** This also means there is a risk of the legend going beyond scale bounds
                    // We need to use the barAxis min and max just to be sure the bar is complete
                    //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
                    // ** We also need to create patches for the scale if the labels exceed bounds
                    //     (floating point comparisons risky for small data ranges,but not a big deal
                    //      because patches will be indistinguishable from actual scale bottom)
                    // It's likely that scale clamping will actually do this for us elegantly
                    // ...but better to be safer and patch the regions anyways

                    for (let i = 0; i < legendBarWidth; i = i + stepSize) {

                        let center = i + (stepSize / 2);
                        let dataCenter = barAxis.scale().invert(center);

                        // below normal scale bounds
                        if (dataCenter < legendMinMax[0]) {
                            bar.append("rect")
                                .attr("x", i)
                                .attr("y", 0)
                                .attr("width", stepSize)
                                .attr("height", barHeight)
                                .style("fill", legendColorScale(legendMinMax[0]));
                        }
                        // within normal scale bounds
                        else if (dataCenter < legendMinMax[1]) {
                            bar.append("rect")
                                .attr("x", i)
                                .attr("y", 0)
                                .attr("width", stepSize)
                                .attr("height", barHeight)
                                .style("fill", legendColorScale(dataCenter));
                        }
                        // above normal scale bounds
                        else {
                            bar.append("rect")
                                .attr("x", i)
                                .attr("y", 0)
                                .attr("width", stepSize)
                                .attr("height", barHeight)
                                .style("fill", legendColorScale(legendMinMax[1]));
                        }

                    }
                }
                // Otherwise we have a nominal scale
                else {
                    let nomVals = legendColorScale.domain().sort();

                    // Use a scaleBand to make blocks of color and simple labels
                    let barScale = d3.scaleBand().domain(nomVals)
                        .range([0, legendBarWidth])
                        .padding(0.05);
                    barAxis.scale(barScale);

                    // Draw rectangles for each nominal entry
                    nomVals.forEach(d => {
                        bar.append("rect")
                            .attr("x", barScale(d))
                            .attr("y", 0)
                            .attr("width", barScale.bandwidth())
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(d));
                    });
                }
                // DONE w/SWITCH

                // Finally, draw legend labels at top left of the selected canvas
                mapArea.append("g")
                    .attr("class", "legend axis")
                    .attr("transform", `translate(${offsets.width},${legendHeight})`)
                    .call(barAxis);

            }

            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // above credited in codesource.js

            const requestData = async function () {
                // fetch data
                let mapData = await d3.json('combined_data.json');
                console.log(mapData);

                // canvas to hold map
                let svg = d3.select("svg#mapArea");
                // setting margins and map area
                const height = svg.attr("height");
                const width = svg.attr("width");

                // drawing world map outlines on svg canvas
                let land = topojson.feature(mapData, mapData.objects.land);
                let countries = topojson.feature(mapData, mapData.objects.countries);
                let countriesMesh = topojson.mesh(mapData, mapData.objects.countries);
                var projection = d3.geoMercator().fitSize([width, height], land);
                var path = d3.geoPath().projection(projection);
                let map = svg.append("g");
                let countriesMeshPath = map.append("path").datum(countriesMesh)
                                           .attr("class", "countrymesh")
                                           .attr("fill", "none")
                                           .attr("stroke", "white")
                                           .attr("stroke-width", "1")
                                           .attr("d", path);
                map.raise();

                // create colorScale where domain is a list of life expectancies
                let life_quintiles = ["#8B0000","#CD5C5C","#FFD700","#9ACD32","#006400"];
                const lifeScale = d3.scaleQuantile()
                                    .domain(mapData['life_expectancies'])
                                    .range(life_quintiles);
                
                // create colorScale where domain is a list of population size
                let pop_quintiles = ["#7FCDBB", "#41B6C4", "#FDAE61", "#F46D43", "#D73027"]
                // get list of every population value
                let pops = [];
                mapData.objects.countries.geometries.forEach(function (country) {
                    for (let currYear = 1960; currYear <= 2022; currYear++) {
                        if (typeof country.properties[String(currYear)] == "object") pops.push(country.properties[String(currYear)].population);
                    }
                })
                const popScale = d3.scaleQuantile()
                                   .domain(pops)
                                   .range(pop_quintiles);
                                
                // creating text box at bottom left of map describing country and corresponding life expectancy
                let tooltipWidth = 325;
                let tooltipHeight = 50;
                let momesh =  map.append("path")
                                 .attr("class","mouseover")
                                 .style("stroke", "black")
                                 .style("stroke-width", 3)
                                 .style("fill", "none")
                                 .attr("d", "");
                let tooltip = svg.append("g")
                                 .attr("class","tooltip")
                                 .attr("visibility","hidden")
                                 .attr("transform",`translate(${width/4 - 80},${(height/4) * 3 - 50})`);
                tooltip.append("rect")
                       .attr("fill", "white")
                       .attr("opacity", 1)
                       .attr("stroke", "black")
                       .attr("x", -tooltipWidth / 2.0)
                       .attr("y", -tooltipHeight / 7.0 + 2.5)
                       .attr("width",tooltipWidth)
                       .attr("height",tooltipHeight)
                let txt = tooltip.append("text")
                                 .attr("fill", "black")
                                 .attr("text-anchor","middle")
                                 .attr("alignment-baseline","hanging")
                                 .attr("x", 0)
                                 .attr("y", 2)
                                 .attr('font-size', 20)
                                 .style("font-weight", "bold")
                let txt2 = tooltip.append("text")
                                 .attr("fill", "black")
                                 .attr("text-anchor","middle")
                                 .attr("alignment-baseline","hanging")
                                 .attr("x", 0)
                                 .attr("y", 22)
                                 .attr('font-size', 20)

                // creating slider to select year, as well as an associated axis for visual clarity
                let divSlider = d3.select("div.sliderContainer");
                let sliderWidth = Number(divSlider.style("width").substring(0, divSlider.style("width").length - 2));
                let sliderHeight = Number(divSlider.style("height").substring(0, divSlider.style("height").length - 2));
                let xScale = d3.scaleLinear().domain([1960, 2022])
                                             .range([10, sliderWidth-6]);
                let xAxis = d3.axisBottom(xScale);
                xAxis.tickFormat(d => d % 5 == 0 ? String(d) : "").ticks(63);
                let canvas = divSlider.append("svg")
                                      .attr("width", sliderWidth)
                                      .attr("height", sliderHeight)
                                      .attr("class", "axis")
                                      .style('overflow', "visible")
                canvas.append("g").attr("transform", `translate(${0}, ${sliderHeight/3-10})`)
                                  .attr("class", "axis")
                                  .call(xAxis)
                // if year is divisible by 5, make its axis tick longer
                d3.selectAll("g.axis g.tick line")
                            .attr("y2", function(d){
                                if ( d % 5 == 0 ) 
                                    return 10;
                                else
                                    return 4;
                            });
                // if year is divisible by 5, move axis tick label accordingly to appear below elongated tick
                d3.selectAll("g.axis g.tick text")
                            .attr("y", function(d){
                                if ( d % 5 == 0 )
                                    return 15;
                                else
                                    return 4;
                            });

                var selectedCountry = undefined; // Variable to hold most recent country that was moused/hovered over
                var year = 1960; // Variable to hold the current year

                // when mouse enters country, make thick black outline around country
                // also show country name and life expectancy or population in text box (tooltip)
                function mouseEntersCountry() {

                    tooltip.style("visibility","visible")

                    // get current life expectancy or population data
                    selectedCountry = d3.select(this);
                    let country_obj = selectedCountry == undefined ? undefined : selectedCountry.datum().properties[String(year)];
                    let life_exp = country_obj == undefined ? undefined 
                                   : typeof country_obj == "object" ? country_obj.life
                                   : country_obj;
                    let pop = country_obj == undefined ? undefined
                              : typeof country_obj == "object" ? country_obj.population : undefined;
                    let name = selectedCountry.datum().properties['name'];
                    let id = selectedCountry.datum().id
                    
                    // put name of country into textbox
                    txt.text(name);
                    
                    // if statement to check if we are showing population or life expectancy in textbox
                    if (showLife) {
                        // if no life expectancy data for country, then life expectancy is N/A
                        // color text according to colorScale
                        if (life_exp == undefined) {
                        txt2.text("Life Expectancy: N/A")
                            .transition()
                            .duration(mapTransitionTime)
                            .attr("fill", "lightgrey");
                        }
                        else {
                            txt2.text("Life Expectancy: " + d3.format(".2f")(life_exp))
                                .transition()
                                .duration(mapTransitionTime)
                                .attr("fill", lifeScale(life_exp));
                        }
                    }
                    else {
                        // if no population data for country, then population is N/A
                        // color text according to colorScale
                        if (pop == undefined) {
                            txt2.text("Population: N/A")
                                .transition()
                                .duration(mapTransitionTime)
                                .attr("fill", "lightgrey");
                        }
                        else {
                            txt2.text("Population: " + d3.format(",")(pop))
                                .transition()
                                .duration(mapTransitionTime)
                                .attr("fill", popScale(pop));
                        }
                    }
                    
                    // make thick black outline around country
                    var mo = topojson.mesh(mapData, mapData.objects.countries, function(a, b) { 
                        return a.properties.name === name || b.properties.name === name;
                    });
                    momesh.datum(mo).attr("d", path)

                    // make sure outline/textbox is above every other element in canvas
                    momesh.raise();
                    tooltip.raise();

                }

                // when mouse leaves country, remove thick black outline around country
                // also make text box (tooltip) disappear
                function mouseLeavesCountry() {

                    tooltip.style("visibility","hidden");
                
                    let country = d3.select(this);
                
                    momesh.attr("d", "");
                }

                // add mouseover and mouseout events for each country
                // update life expectancy/population colors for each country and animate this color transition
                // update textbox (tooltip) so that the color of the life expectancy/population text transitions 
                // according to the selected country's color
                function updateMap() {                   
                    let countriesOutlines = map.selectAll("path.country").data(countries.features)
                        .join(
                            // when new data is entered, color countries by their new life expectancy or population data
                            // depending on what we are currently showing
                            // transition to new color
                            enter => enter.append("path")
                                            .attr("fill", d => {
                                                if (d.properties[String(year)] == undefined) return "lightgrey";
                                                else if (showLife) {
                                                    if (typeof d.properties[String(year)] == "object") return lifeScale(d.properties[String(year)].life);
                                                    else return lifeScale(d.properties[String(year)]);
                                                }
                                                else {
                                                    if (typeof d.properties[String(year)] == "object") return popScale(d.properties[String(year)].population);
                                                    else return "lightgrey"
                                                }
                                            })
                                            .attr("opacity", 0)
                                            .call( enter => enter.transition().duration(mapTransitionTime)
                                                                 .attr("opacity", 1)),
                            update => update.call( update => update.transition().duration(mapTransitionTime).attr("fill", d => {
                                                if (d.properties[String(year)] == undefined) return "lightgrey";
                                                else if (showLife) {
                                                    if (typeof d.properties[String(year)] == "object") return lifeScale(d.properties[String(year)].life);
                                                    else return lifeScale(d.properties[String(year)]);
                                                }
                                                else {
                                                    if (typeof d.properties[String(year)] == "object") return popScale(d.properties[String(year)].population);
                                                    else return "lightgrey"
                                                }
                                            })),
                            // when old data leaves, get rid of that country's previous color
                            exit => exit.call( exit => exit.transition().duration(mapTransitionTime).attr('opacity', 0).remove())
                        )
                        .attr("class", "country")
                        .attr("d", path)
                        .attr("stroke", "none")
                        .on('mouseover',  mouseEntersCountry)
                        .on('mouseout',  mouseLeavesCountry)

                    // update textbox (tooltip) so that the color of the life expectancy/population text transitions to current data
                    let country_obj = selectedCountry == undefined ? undefined : selectedCountry.datum().properties[String(year)];

                    // if statement to check if we currently showing life expectancy or population
                    if (showLife) {
                        // if no life expectancy data for country, then life expectancy is N/A
                        // update text color according to colorScale
                        let life_exp = country_obj == undefined ? undefined 
                                   : typeof country_obj == "object" ? country_obj.life
                                   : country_obj;
                                   if (life_exp == undefined) {
                        txt2.text("Life Expectancy: N/A")
                            .transition()
                            .duration(mapTransitionTime)
                            .attr("fill", "lightgrey");
                        }
                        else {
                            txt2.text("Life Expectancy: " + d3.format(".2f")(life_exp))
                                .transition()
                                .duration(mapTransitionTime)
                                .attr("fill", lifeScale(life_exp));
                        }
                    }
                    else {
                        // if no population data for country, then population is N/A
                        // update text color according to colorScale
                        let pop = country_obj == undefined ? undefined
                                  : typeof country_obj == "object" ? country_obj.population 
                                  : undefined;
                        if (pop == undefined) {
                            txt2.text("Population: N/A")
                                .transition()
                                .duration(mapTransitionTime)
                                .attr("fill", "lightgrey");
                        }
                        else {
                            txt2.text("Population: " + d3.format(",")(pop))
                                .transition()
                                .duration(mapTransitionTime)
                                .attr("fill", popScale(pop));
                        }
                    }
                    map.raise();
                    countriesMeshPath.raise();
                    momesh.raise()
                }   

                // drawing legend at top left of our canvas containing the world map
                drawLegend("#mapArea", lifeScale, 75, 425);

                // whenever user interacts with slider
                // update year, update textbox containing the current year and colors of country by calling updateMap()
                d3.select("input.yearSlider").on("input", (event) =>  {
                    year = event.target.valueAsNumber;
                    // update value of slider
                    d3.select('div.sliderValue').text("Year: " + year);
                    // update map
                    updateMap();    
                })

                // We do not want to start with a blank screen, so call it once
                updateMap();

                // animate slider
                let animate = true;
                let sliderTransitionTime = 2000;
                // call function every two seconds
                setInterval(function () {
                    // enter if-statement when we we want to animate slider
                    if (animate) {
                        year += 1; // increment year
                        if (year == 2023) year = 1960; // if year is 2023, reset back to 1960
                        d3.select('div.sliderValue').text("Year: " + year); // update textbox containing current year
                        d3.select("input.yearSlider").property("value", year); // update current value of slider to move it 
                        updateMap(); // call update map
                        tooltip.raise();
                        svg.selectAll("g.text").raise();
                        svg.selectAll("g.legend").raise();
                    }
                }, sliderTransitionTime)

                // adding eventlistener to pause/unpause animation when space is pressed
                // and to set the year when enter is pressed
                d3.select("body").on("keydown", function(event) {
                    if(event.keyCode === 32) {
                        event.preventDefault();
                        animate = !animate;
                    }
                    if(event.keyCode === 13) {
                        event.preventDefault();
                        let currYear = Number(d3.select("input#yearText").property("value")); 
                        // check if value inside textbox is a valid year
                        if (currYear >= 1960 && currYear <= 2022) {
                            year = currYear;
                            d3.select('div.sliderValue').text("Year: " + year); // update textbox containing current year
                            d3.select("input.yearSlider").property("value", year); // update current value of slider to move it 
                            updateMap();
                        }
                        d3.select("input#yearText").property("value", "")
                    }
                })

                d3.select("#play").on("click", () => {
                    // Start animating the slider
                    animate = true;
                });
                d3.select("#stop").on("click", () => {
                    // Pause animation
                    animate = false;
                });

                d3.select("#life").on("click", () => {
                    // Show life expectancy on map
                    showLife = true;
                    // call updateMap() to show life expectancy data
                    updateMap();
                    // remove previous legend and add new legend for life expectancy data
                    svg.selectAll("g.text").remove();
                    svg.selectAll("g.legend").remove();
                    drawLegend("#mapArea", lifeScale, 75, 425);
                });

                d3.select("#pop").on("click", () => {
                    // Show population on map
                    showLife = false;
                    // call updateMap() to show population data
                    updateMap();
                    // remove previous legend and add new legend for population data
                    svg.selectAll("g.text").remove();
                    svg.selectAll("g.legend").remove();
                    drawLegend("#mapArea", popScale, 75, 425);
                });

                // handle zooming
                var zoom = d3.zoom()
                    .scaleExtent([1,200])
                    .translateExtent([[0,0],[width,height]])  // to lock to edges
                    .on("zoom", mapZoomed);
                svg.call(zoom);

                // call initially so map is by default zoomed out
                svg.call(zoom.transform, d3.zoomIdentity);

                function mapZoomed({transform}) {         
                    // Transform the group object to reflect the zoom action
                    map.attr("transform", transform.toString() );
                
                    // Divide by scale to make sure strokes remain a consistent width during zooming
                    map.select("path.countrymesh")
                       .style("stroke-width", 1 / transform.k);
                    map.select("path.country")
                       .style("stroke-width", 1 / transform.k);
                    momesh.style("stroke-width", 3 / transform.k);
                    
                    
                    // keep legend and textbox above other elements in map
                    tooltip.raise();
                    svg.selectAll("g.text").raise();
                    svg.selectAll("g.legend").raise();
                }

                // reset view/zoom of map
                d3.select("#resetZoom").on("click", () => {
                    // Reset zoom
                    svg.transition().duration(1000).call(zoom.transform, d3.zoomIdentity);
                });

                map.selectAll("path.country").on("click",clicked);
                
                // below code credited in codesource.js
                // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

                function clicked(event, d) {
            
                    // geoPath generators have a few extra functions. .bounds returns a pixel rectangle bounding the shape you give it
                    let bounds = path.bounds(d.geometry); // get bounds for clicked state/county
                    let dx = bounds[1][0] - bounds[0][0]; // width of state/county
                    let dy = bounds[1][1] - bounds[0][1]; // height of state/county
                    let x = (bounds[0][0] + bounds[1][0]) / 2; // center x of state/county
                    let y = (bounds[0][1] + bounds[1][1]) / 2; // center y of state/county
            
                    // We want to make sure scale is within 1-10 when we click, so things don't zoom too far or too little
                    // To compute zoom, we want to make sure the bounding box "just" fits onscreen.
                    // dx / mapWidth gets us the portion of the screen the shape takes up without any zoom at all
                    //  the lower dx/mapWidth is, the more we need to zoom because the shape is smaller
                    // We find the max of dx/mapWidth, dy/mapHeight because we don't want to zoom farther (smaller values need more zoom)
                    // We do 1 or 0.9 divided by dx/mapWidth because we need larger numbers to zoom in. 0.9 allows us to pad things a bit
                    let scale = Math.max(1, Math.min(10, 0.9 / Math.max( dx / width, 
                                                                        dy / height )));
            
                    // Think of the translate like a delta describing how much we need to move the map to move a point to a desired position
                    // Simplistically, it works like (desired position) - (current position) = (translation)
                    // In this case mapWidth/2, the center of the screen is the desired place for our viewport
                    // x*scale is the position we want to move to the center (scale is there because we need to move more when zoomed in)
                    let translate = [width / 2 - x * scale, height / 2 - y * scale];
            
                    // It's hard to programmatically adjust a zoom. The best way is to take the Identity (zoom transform where nothing is changed)
                    //  and then modify it using a .translate and .scale
                    let newTransform = d3.zoomIdentity
                                        .translate(translate[0],translate[1])
                                        .scale(scale);
                    // We can apply a new transform to the screen by using .call(zoom.tranform, newTransform)
                    // This is kinda the same thing as running zoom.transform(newTransform), but the chaining with .call allows us to add an animation
                    svg.transition().duration(1000).call(zoom.transform, newTransform);
            
                }

                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // above credited in codesource.js
                
            }

            requestData();

        </script>
    </p>
</body>

</html>